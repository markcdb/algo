{
  "problems" : [
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 8,
      "id" : "longest-substring-without-repeating-characters",
      "pattern" : "slidingWindow",
      "prompt" : "Given a string s, find the length of the longest substring without repeating characters.\n\nExample 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\nExample 2:\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n\nExample 3:\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\n\nConstraints:\n- 0 <= s.length <= 5 * 10^4\n- s consists of English letters, digits, symbols and spaces.",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func lengthOfLongestSubstring(_ s: String) -> Int {\n    var charSet = Set<Character>()\n    var left = 0\n    var maxLength = 0\n    let chars = Array(s)\n    \n    for right in 0..<chars.count {\n        while charSet.contains(chars[right]) {\n            charSet.remove(chars[left])\n            left += 1\n        }\n        charSet.insert(chars[right])\n        maxLength = max(maxLength, right - left + 1)\n    }\n    \n    return maxLength\n}",
          "wrapper" : "\n\nprint(lengthOfLongestSubstring(readLine()!))"
        },
        {
          "language" : "python",
          "code" : "def lengthOfLongestSubstring(s):\n    char_set = set()\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length",
          "wrapper" : "\n\ns = input()\nprint(lengthOfLongestSubstring(s))"
        },
        {
          "language" : "java",
          "code" : "import java.util.*;\n\nclass Solution {\n    public static int lengthOfLongestSubstring(String s) {\n        Set<Character> charSet = new HashSet<>();\n        int left = 0;\n        int maxLength = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            while (charSet.contains(s.charAt(right))) {\n                charSet.remove(s.charAt(left));\n                left++;\n            }\n            charSet.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.nextLine();\n        System.out.println(Solution.lengthOfLongestSubstring(s));\n    }\n}"
        }
      ],
      "tags" : [
        "sliding window",
        "string",
        "hash set"
      ],
      "testCases" : [
        {
          "expectedOutput" : "3",
          "explanation" : "The answer is \"abc\", with the length of 3.",
          "input" : "abcabcbb"
        },
        {
          "expectedOutput" : "1",
          "explanation" : "The answer is \"b\", with the length of 1.",
          "input" : "bbbbb"
        },
        {
          "expectedOutput" : "3",
          "explanation" : "The answer is \"wke\", with the length of 3.",
          "input" : "pwwkew"
        }
      ],
      "title" : "Longest Substring Without Repeating Characters"
    },
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 10,
      "id" : "longest-substring-with-at-most-k-distinct-characters",
      "pattern" : "slidingWindow",
      "prompt" : "Given a string s and an integer k, return the length of the longest substring of s that contains at most k distinct characters.\n\nExample 1:\nInput: s = \"eceba\", k = 2\nOutput: 3\nExplanation: The substring is \"ece\" with length 3.\n\nExample 2:\nInput: s = \"aa\", k = 1\nOutput: 2\nExplanation: The substring is \"aa\" with length 2.\n\nConstraints:\n- 1 <= s.length <= 5 * 10^4\n- 0 <= k <= 50",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func lengthOfLongestSubstringKDistinct(_ s: String, _ k: Int) -> Int {\n    guard k > 0 else { return 0 }\n    let chars = Array(s)\n    var charCount = [Character: Int]()\n    var left = 0\n    var maxLength = 0\n    \n    for right in 0..<chars.count {\n        charCount[chars[right], default: 0] += 1\n        \n        while charCount.count > k {\n            charCount[chars[left]]! -= 1\n            if charCount[chars[left]] == 0 {\n                charCount.removeValue(forKey: chars[left])\n            }\n            left += 1\n        }\n        \n        maxLength = max(maxLength, right - left + 1)\n    }\n    \n    return maxLength\n}",
          "wrapper" : "\n\nlet input = readLine()!.split(separator: \"|\")\nlet s = String(input[0])\nlet k = Int(input[1])!\nprint(lengthOfLongestSubstringKDistinct(s, k))"
        },
        {
          "language" : "python",
          "code" : "def lengthOfLongestSubstringKDistinct(s, k):\n    if k == 0:\n        return 0\n    char_count = {}\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        char_count[s[right]] = char_count.get(s[right], 0) + 1\n        \n        while len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n        \n        max_length = max(max_length, right - left + 1)\n    \n    return max_length",
          "wrapper" : "\n\nline = input().split('|')\ns = line[0]\nk = int(line[1])\nprint(lengthOfLongestSubstringKDistinct(s, k))"
        },
        {
          "language" : "java",
          "code" : "import java.util.*;\n\nclass Solution {\n    public static int lengthOfLongestSubstringKDistinct(String s, int k) {\n        if (k == 0) return 0;\n        Map<Character, Integer> charCount = new HashMap<>();\n        int left = 0;\n        int maxLength = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            charCount.put(s.charAt(right), charCount.getOrDefault(s.charAt(right), 0) + 1);\n            \n            while (charCount.size() > k) {\n                charCount.put(s.charAt(left), charCount.get(s.charAt(left)) - 1);\n                if (charCount.get(s.charAt(left)) == 0) {\n                    charCount.remove(s.charAt(left));\n                }\n                left++;\n            }\n            \n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] parts = sc.nextLine().split(\"\\\\|\");\n        String s = parts[0];\n        int k = Integer.parseInt(parts[1]);\n        System.out.println(Solution.lengthOfLongestSubstringKDistinct(s, k));\n    }\n}"
        }
      ],
      "tags" : [
        "sliding window",
        "hash map",
        "string"
      ],
      "testCases" : [
        {
          "expectedOutput" : "3",
          "explanation" : "The substring is \"ece\" with length 3",
          "input" : "eceba|2"
        },
        {
          "expectedOutput" : "2",
          "explanation" : "The substring is \"aa\" with length 2",
          "input" : "aa|1"
        }
      ],
      "title" : "Longest Substring with At Most K Distinct Characters"
    },
    {
      "difficulty" : "hard",
      "estimatedTimeMinutes" : 15,
      "id" : "minimum-window-substring",
      "pattern" : "slidingWindow",
      "prompt" : "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n\nExample 1:\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n\nExample 2:\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\n\nConstraints:\n- 1 <= s.length, t.length <= 10^5\n- s and t consist of uppercase and lowercase English letters.",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func minWindow(_ s: String, _ t: String) -> String {\n    let sChars = Array(s)\n    var need = [Character: Int]()\n    var window = [Character: Int]()\n    \n    for char in t {\n        need[char, default: 0] += 1\n    }\n    \n    var left = 0, right = 0\n    var valid = 0\n    var start = 0, length = Int.max\n    \n    while right < sChars.count {\n        let c = sChars[right]\n        right += 1\n        \n        if let count = need[c] {\n            window[c, default: 0] += 1\n            if window[c] == count {\n                valid += 1\n            }\n        }\n        \n        while valid == need.count {\n            if right - left < length {\n                start = left\n                length = right - left\n            }\n            \n            let d = sChars[left]\n            left += 1\n            \n            if let count = need[d] {\n                if window[d] == count {\n                    valid -= 1\n                }\n                window[d]! -= 1\n            }\n        }\n    }\n    \n    return length == Int.max ? \"\" : String(sChars[start..<start+length])\n}",
          "wrapper" : "\n\nlet input = readLine()!.split(separator: \"|\")\nlet s = String(input[0])\nlet t = String(input[1])\nprint(minWindow(s, t))"
        },
        {
          "language" : "python",
          "code" : "def minWindow(s, t):\n    need = {}\n    window = {}\n    \n    for char in t:\n        need[char] = need.get(char, 0) + 1\n    \n    left = right = 0\n    valid = 0\n    start = 0\n    length = float('inf')\n    \n    while right < len(s):\n        c = s[right]\n        right += 1\n        \n        if c in need:\n            window[c] = window.get(c, 0) + 1\n            if window[c] == need[c]:\n                valid += 1\n        \n        while valid == len(need):\n            if right - left < length:\n                start = left\n                length = right - left\n            \n            d = s[left]\n            left += 1\n            \n            if d in need:\n                if window[d] == need[d]:\n                    valid -= 1\n                window[d] -= 1\n    \n    return \"\" if length == float('inf') else s[start:start+length]",
          "wrapper" : "\n\nline = input().split('|')\ns = line[0]\nt = line[1]\nprint(minWindow(s, t))"
        },
        {
          "language" : "java",
          "code" : "import java.util.*;\n\nclass Solution {\n    public static String minWindow(String s, String t) {\n        Map<Character, Integer> need = new HashMap<>();\n        Map<Character, Integer> window = new HashMap<>();\n        \n        for (char c : t.toCharArray()) {\n            need.put(c, need.getOrDefault(c, 0) + 1);\n        }\n        \n        int left = 0, right = 0;\n        int valid = 0;\n        int start = 0, length = Integer.MAX_VALUE;\n        \n        while (right < s.length()) {\n            char c = s.charAt(right);\n            right++;\n            \n            if (need.containsKey(c)) {\n                window.put(c, window.getOrDefault(c, 0) + 1);\n                if (window.get(c).equals(need.get(c))) {\n                    valid++;\n                }\n            }\n            \n            while (valid == need.size()) {\n                if (right - left < length) {\n                    start = left;\n                    length = right - left;\n                }\n                \n                char d = s.charAt(left);\n                left++;\n                \n                if (need.containsKey(d)) {\n                    if (window.get(d).equals(need.get(d))) {\n                        valid--;\n                    }\n                    window.put(d, window.get(d) - 1);\n                }\n            }\n        }\n        \n        return length == Integer.MAX_VALUE ? \"\" : s.substring(start, start + length);\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] parts = sc.nextLine().split(\"\\\\|\");\n        String s = parts[0];\n        String t = parts[1];\n        System.out.println(Solution.minWindow(s, t));\n    }\n}"
        }
      ],
      "tags" : [
        "sliding window",
        "hash map",
        "string"
      ],
      "testCases" : [
        {
          "expectedOutput" : "BANC",
          "explanation" : "The minimum window substring includes A, B, and C",
          "input" : "ADOBECODEBANC|ABC"
        },
        {
          "expectedOutput" : "a",
          "explanation" : "The entire string is the minimum window",
          "input" : "a|a"
        }
      ],
      "title" : "Minimum Window Substring"
    },
    {
      "difficulty" : "easy",
      "estimatedTimeMinutes" : 5,
      "id" : "max-sum-subarray-of-size-k",
      "pattern" : "slidingWindow",
      "prompt" : "Given an array of positive integers and a number k, find the maximum sum of any contiguous subarray of size k.\n\nExample 1:\nInput: arr = [2, 1, 5, 1, 3, 2], k = 3\nOutput: 9\nExplanation: Subarray [5, 1, 3] has the maximum sum of 9.\n\nExample 2:\nInput: arr = [2, 3, 4, 1, 5], k = 2\nOutput: 7\nExplanation: Subarray [3, 4] has the maximum sum of 7.\n\nConstraints:\n- 1 <= arr.length <= 10^5\n- 1 <= k <= arr.length",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func maxSumSubarray(_ arr: [Int], _ k: Int) -> Int {\n    guard arr.count >= k else { return 0 }\n    \n    var windowSum = 0\n    var maxSum = 0\n    \n    \/\/ Calculate sum of first window\n    for i in 0..<k {\n        windowSum += arr[i]\n    }\n    maxSum = windowSum\n    \n    \/\/ Slide the window\n    for i in k..<arr.count {\n        windowSum = windowSum - arr[i - k] + arr[i]\n        maxSum = max(maxSum, windowSum)\n    }\n    \n    return maxSum\n}",
          "wrapper" : "\n\nlet input = readLine()!.split(separator: \"|\")\nlet arr = input[0].dropFirst().dropLast().split(separator: \",\").map { Int($0)! }\nlet k = Int(input[1])!\nprint(maxSumSubarray(arr, k))"
        },
        {
          "language" : "python",
          "code" : "def maxSumSubarray(arr, k):\n    if len(arr) < k:\n        return 0\n    \n    window_sum = sum(arr[:k])\n    max_sum = window_sum\n    \n    for i in range(k, len(arr)):\n        window_sum = window_sum - arr[i - k] + arr[i]\n        max_sum = max(max_sum, window_sum)\n    \n    return max_sum",
          "wrapper" : "\n\nline = input().split('|')\narr = list(map(int, line[0].strip('[]').split(',')))\nk = int(line[1])\nprint(maxSumSubarray(arr, k))"
        },
        {
          "language" : "java",
          "code" : "class Solution {\n    public static int maxSumSubarray(int[] arr, int k) {\n        if (arr.length < k) return 0;\n        \n        int windowSum = 0;\n        for (int i = 0; i < k; i++) {\n            windowSum += arr[i];\n        }\n        int maxSum = windowSum;\n        \n        for (int i = k; i < arr.length; i++) {\n            windowSum = windowSum - arr[i - k] + arr[i];\n            maxSum = Math.max(maxSum, windowSum);\n        }\n        \n        return maxSum;\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] parts = sc.nextLine().split(\"\\\\|\");\n        String[] nums = parts[0].replace(\"[\", \"\").replace(\"]\", \"\").split(\",\");\n        int[] arr = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            arr[i] = Integer.parseInt(nums[i]);\n        }\n        int k = Integer.parseInt(parts[1]);\n        System.out.println(Solution.maxSumSubarray(arr, k));\n    }\n}"
        }
      ],
      "tags" : [
        "sliding window",
        "array"
      ],
      "testCases" : [
        {
          "expectedOutput" : "9",
          "explanation" : "Subarray [5, 1, 3] has the maximum sum of 9",
          "input" : "[2,1,5,1,3,2]|3"
        },
        {
          "expectedOutput" : "7",
          "explanation" : "Subarray [3, 4] has the maximum sum of 7",
          "input" : "[2,3,4,1,5]|2"
        }
      ],
      "title" : "Max Sum Subarray of Size K"
    },
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 8,
      "id" : "number-of-subarrays-with-sum-less-than-k",
      "pattern" : "slidingWindow",
      "prompt" : "Given an array of positive integers nums and an integer k, return the number of contiguous subarrays where the sum of elements is less than k.\n\nExample 1:\nInput: nums = [1, 2, 3], k = 7\nOutput: 6\nExplanation: The 6 subarrays are [1], [2], [3], [1,2], [2,3], [1,2,3]\n\nExample 2:\nInput: nums = [10, 5, 2, 6], k = 100\nOutput: 10\n\nConstraints:\n- 1 <= nums.length <= 3 * 10^4\n- 1 <= nums[i] <= 1000\n- 0 <= k <= 10^6",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func numSubarraysWithSum(_ nums: [Int], _ k: Int) -> Int {\n    var count = 0\n    var left = 0\n    var sum = 0\n    \n    for right in 0..<nums.count {\n        sum += nums[right]\n        \n        while sum >= k && left <= right {\n            sum -= nums[left]\n            left += 1\n        }\n        \n        \/\/ All subarrays from left to right have sum < k\n        count += right - left + 1\n    }\n    \n    return count\n}",
          "wrapper" : "\n\nlet input = readLine()!.split(separator: \"|\")\nlet nums = input[0].dropFirst().dropLast().split(separator: \",\").map { Int($0)! }\nlet k = Int(input[1])!\nprint(numSubarraysWithSum(nums, k))"
        },
        {
          "language" : "python",
          "code" : "def numSubarraysWithSum(nums, k):\n    count = 0\n    left = 0\n    total = 0\n    \n    for right in range(len(nums)):\n        total += nums[right]\n        \n        while total >= k and left <= right:\n            total -= nums[left]\n            left += 1\n        \n        count += right - left + 1\n    \n    return count",
          "wrapper" : "\n\nline = input().split('|')\nnums = list(map(int, line[0].strip('[]').split(',')))\nk = int(line[1])\nprint(numSubarraysWithSum(nums, k))"
        },
        {
          "language" : "java",
          "code" : "class Solution {\n    public static int numSubarraysWithSum(int[] nums, int k) {\n        int count = 0;\n        int left = 0;\n        int sum = 0;\n        \n        for (int right = 0; right < nums.length; right++) {\n            sum += nums[right];\n            \n            while (sum >= k && left <= right) {\n                sum -= nums[left];\n                left++;\n            }\n            \n            count += right - left + 1;\n        }\n        \n        return count;\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] parts = sc.nextLine().split(\"\\\\|\");\n        String[] nums = parts[0].replace(\"[\", \"\").replace(\"]\", \"\").split(\",\");\n        int[] arr = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            arr[i] = Integer.parseInt(nums[i]);\n        }\n        int k = Integer.parseInt(parts[1]);\n        System.out.println(Solution.numSubarraysWithSum(arr, k));\n    }\n}"
        }
      ],
      "tags" : [
        "sliding window",
        "array",
        "prefix sum"
      ],
      "testCases" : [

      ],
      "title" : "Number of Subarrays with Sum Less Than K"
    },
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 7,
      "id" : "container-with-most-water",
      "pattern" : "twoPointers",
      "prompt" : "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n\nFind two lines that together with the x-axis form a container that holds the most water. Return the maximum amount of water a container can store.\n\nExample 1:\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The vertical lines are at indices 1 and 8, with heights 8 and 7.\n\nExample 2:\nInput: height = [1,1]\nOutput: 1\n\nConstraints:\n- n == height.length\n- 2 <= n <= 10^5\n- 0 <= height[i] <= 10^4",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func maxArea(_ height: [Int]) -> Int {\n    var left = 0\n    var right = height.count - 1\n    var maxArea = 0\n    \n    while left < right {\n        let width = right - left\n        let h = min(height[left], height[right])\n        maxArea = max(maxArea, width * h)\n        \n        if height[left] < height[right] {\n            left += 1\n        } else {\n            right -= 1\n        }\n    }\n    \n    return maxArea\n}",
          "wrapper" : "\n\nlet input = readLine()!\nlet height = input.dropFirst().dropLast().split(separator: \",\").map { Int($0.trimmingCharacters(in: .whitespaces))! }\nprint(maxArea(height))"
        },
        {
          "language" : "python",
          "code" : "def maxArea(height):\n    left = 0\n    right = len(height) - 1\n    max_area = 0\n    \n    while left < right:\n        width = right - left\n        h = min(height[left], height[right])\n        max_area = max(max_area, width * h)\n        \n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_area",
          "wrapper" : "\n\nheight = list(map(int, input().strip('[]').split(',')))\nprint(maxArea(height))"
        },
        {
          "language" : "java",
          "code" : "class Solution {\n    public static int maxArea(int[] height) {\n        int left = 0;\n        int right = height.length - 1;\n        int maxArea = 0;\n        \n        while (left < right) {\n            int width = right - left;\n            int h = Math.min(height[left], height[right]);\n            maxArea = Math.max(maxArea, width * h);\n            \n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return maxArea;\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String input = sc.nextLine().replace(\"[\", \"\").replace(\"]\", \"\").replace(\" \", \"\");\n        String[] nums = input.split(\",\");\n        int[] height = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            height[i] = Integer.parseInt(nums[i]);\n        }\n        System.out.println(Solution.maxArea(height));\n    }\n}"
        }
      ],
      "tags" : [
        "two pointers",
        "array",
        "greedy"
      ],
      "testCases" : [
        {
          "expectedOutput" : "49",
          "explanation" : "The vertical lines are at indices 1 and 8",
          "input" : "[1,8,6,2,5,4,8,3,7]"
        },
        {
          "expectedOutput" : "1",
          "input" : "[1,1]"
        },
        {
          "expectedOutput" : "16",
          "explanation" : "The container uses indices 0 and 4",
          "input" : "[4,3,2,1,4]"
        }
      ],
      "title" : "Container With Most Water"
    },
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 12,
      "id" : "three-sum",
      "pattern" : "twoPointers",
      "prompt" : "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\nExample 1:\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\n\nExample 2:\nInput: nums = [0,1,1]\nOutput: []\n\nConstraints:\n- 3 <= nums.length <= 3000\n- -10^5 <= nums[i] <= 10^5",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func threeSum(_ nums: [Int]) -> [[Int]] {\n    let sorted = nums.sorted()\n    var result: [[Int]] = []\n    \n    for i in 0..<sorted.count - 2 {\n        if i > 0 && sorted[i] == sorted[i - 1] { continue }\n        \n        var left = i + 1\n        var right = sorted.count - 1\n        \n        while left < right {\n            let sum = sorted[i] + sorted[left] + sorted[right]\n            \n            if sum == 0 {\n                result.append([sorted[i], sorted[left], sorted[right]])\n                \n                while left < right && sorted[left] == sorted[left + 1] { left += 1 }\n                while left < right && sorted[right] == sorted[right - 1] { right -= 1 }\n                \n                left += 1\n                right -= 1\n            } else if sum < 0 {\n                left += 1\n            } else {\n                right -= 1\n            }\n        }\n    }\n    \n    return result\n}",
          "wrapper" : "\n\nlet nums = readLine()!.dropFirst().dropLast().split(separator: \",\").map { Int($0)! }\nlet result = threeSum(nums)\nlet output = \"[\" + result.map { triplet in\n    \"[\" + triplet.map(String.init).joined(separator: \",\") + \"]\"\n}.joined(separator: \",\") + \"]\"\nprint(output)"
        },
        {
          "language" : "python",
          "code" : "def threeSum(nums):\n    nums.sort()\n    result = []\n    \n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        left = i + 1\n        right = len(nums) - 1\n        \n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            \n            if total == 0:\n                result.append([nums[i], nums[left], nums[right]])\n                \n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    \n    return result",
          "wrapper" : "\n\nnums = list(map(int, input().strip('[]').split(',')))\nresult = threeSum(nums)\nprint('[' + ','.join(['[' + ','.join(map(str, triplet)) + ']' for triplet in result]) + ']')"
        },
        {
          "language" : "java",
          "code" : "import java.util.*;\n\nclass Solution {\n    public static List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n        \n        for (int i = 0; i < nums.length - 2; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\n            \n            int left = i + 1;\n            int right = nums.length - 1;\n            \n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                \n                if (sum == 0) {\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                    \n                    while (left < right && nums[left] == nums[left + 1]) left++;\n                    while (left < right && nums[right] == nums[right - 1]) right--;\n                    \n                    left++;\n                    right--;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        \n        return result;\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String input = sc.nextLine().replace(\"[\", \"\").replace(\"]\", \"\");\n        String[] nums = input.split(\",\");\n        int[] arr = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            arr[i] = Integer.parseInt(nums[i].trim());\n        }\n        List<List<Integer>> result = Solution.threeSum(arr);\n        System.out.print(\"[\");\n        for (int i = 0; i < result.size(); i++) {\n            System.out.print(\"[\");\n            List<Integer> triplet = result.get(i);\n            for (int j = 0; j < triplet.size(); j++) {\n                System.out.print(triplet.get(j));\n                if (j < triplet.size() - 1) System.out.print(\",\");\n            }\n            System.out.print(\"]\");\n            if (i < result.size() - 1) System.out.print(\",\");\n        }\n        System.out.println(\"]\");\n    }\n}"
        }
      ],
      "tags" : [
        "two pointers",
        "array",
        "sorting"
      ],
      "testCases" : [

      ],
      "title" : "Three Sum"
    },
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 8,
      "id" : "sort-colors-dutch-national-flag",
      "pattern" : "twoPointers",
      "prompt" : "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n\nYou must solve this problem without using the library's sort function.\n\nExample 1:\nInput: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\n\nExample 2:\nInput: nums = [2,0,1]\nOutput: [0,1,2]\n\nConstraints:\n- n == nums.length\n- 1 <= n <= 300\n- nums[i] is either 0, 1, or 2.",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func sortColors(_ nums: [Int]) -> [Int] {\n    var nums = nums\n    var left = 0      \/\/ boundary for 0s\n    var right = nums.count - 1  \/\/ boundary for 2s\n    var i = 0\n    \n    while i <= right {\n        if nums[i] == 0 {\n            nums.swapAt(i, left)\n            left += 1\n            i += 1\n        } else if nums[i] == 2 {\n            nums.swapAt(i, right)\n            right -= 1\n            \/\/ Don't increment i, need to check swapped value\n        } else {\n            i += 1\n        }\n    }\n    \n    return nums\n}",
          "wrapper" : "\n\nlet nums = readLine()!.dropFirst().dropLast().split(separator: \",\").map { Int($0)! }\nlet result = sortColors(nums)\nprint(\"[\" + result.map(String.init).joined(separator: \",\") + \"]\")"
        },
        {
          "language" : "python",
          "code" : "def sortColors(nums):\n    left = 0\n    right = len(nums) - 1\n    i = 0\n    \n    while i <= right:\n        if nums[i] == 0:\n            nums[i], nums[left] = nums[left], nums[i]\n            left += 1\n            i += 1\n        elif nums[i] == 2:\n            nums[i], nums[right] = nums[right], nums[i]\n            right -= 1\n        else:\n            i += 1\n    \n    return nums",
          "wrapper" : "\n\nnums = list(map(int, input().strip('[]').split(',')))\nresult = sortColors(nums)\nprint('[' + ','.join(map(str, result)) + ']')"
        },
        {
          "language" : "java",
          "code" : "class Solution {\n    public static int[] sortColors(int[] nums) {\n        int left = 0;\n        int right = nums.length - 1;\n        int i = 0;\n        \n        while (i <= right) {\n            if (nums[i] == 0) {\n                int temp = nums[i];\n                nums[i] = nums[left];\n                nums[left] = temp;\n                left++;\n                i++;\n            } else if (nums[i] == 2) {\n                int temp = nums[i];\n                nums[i] = nums[right];\n                nums[right] = temp;\n                right--;\n            } else {\n                i++;\n            }\n        }\n        \n        return nums;\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String input = sc.nextLine().replace(\"[\", \"\").replace(\"]\", \"\");\n        String[] nums = input.split(\",\");\n        int[] arr = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            arr[i] = Integer.parseInt(nums[i].trim());\n        }\n        int[] result = Solution.sortColors(arr);\n        System.out.print(\"[\");\n        for (int i = 0; i < result.length; i++) {\n            System.out.print(result[i]);\n            if (i < result.length - 1) System.out.print(\",\");\n        }\n        System.out.println(\"]\");\n    }\n}"
        }
      ],
      "tags" : [
        "two pointers",
        "array",
        "sorting"
      ],
      "testCases" : [

      ],
      "title" : "Sort Colors (Dutch National Flag)"
    },
    {
      "difficulty" : "easy",
      "estimatedTimeMinutes" : 5,
      "id" : "binary-search",
      "pattern" : "binarySearch",
      "prompt" : "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\nExample 1:\nInput: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4\n\nExample 2:\nInput: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1\n\nConstraints:\n- 1 <= nums.length <= 10^4\n- -10^4 < nums[i], target < 10^4\n- All integers in nums are unique.\n- nums is sorted in ascending order.",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func search(_ nums: [Int], _ target: Int) -> Int {\n    var left = 0\n    var right = nums.count - 1\n    \n    while left <= right {\n        let mid = left + (right - left) \/ 2\n        \n        if nums[mid] == target {\n            return mid\n        } else if nums[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    \n    return -1\n}",
          "wrapper" : "\n\nlet input = readLine()!.split(separator: \"|\")\nlet nums = input[0].dropFirst().dropLast().split(separator: \",\").map { Int($0)! }\nlet target = Int(input[1])!\nprint(search(nums, target))"
        },
        {
          "language" : "python",
          "code" : "def search(nums, target):\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1",
          "wrapper" : "\n\nline = input().split('|')\nnums = list(map(int, line[0].strip('[]').split(',')))\ntarget = int(line[1])\nprint(search(nums, target))"
        },
        {
          "language" : "java",
          "code" : "class Solution {\n    public static int search(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] parts = sc.nextLine().split(\"\\\\|\");\n        String[] nums = parts[0].replace(\"[\", \"\").replace(\"]\", \"\").split(\",\");\n        int[] arr = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            arr[i] = Integer.parseInt(nums[i].trim());\n        }\n        int target = Integer.parseInt(parts[1]);\n        System.out.println(Solution.search(arr, target));\n    }\n}"
        }
      ],
      "tags" : [
        "binary search",
        "array"
      ],
      "testCases" : [
        {
          "expectedOutput" : "4",
          "explanation" : "9 exists in nums and its index is 4",
          "input" : "[-1,0,3,5,9,12]|9"
        },
        {
          "expectedOutput" : "-1",
          "explanation" : "2 does not exist in nums",
          "input" : "[-1,0,3,5,9,12]|2"
        }
      ],
      "title" : "Binary Search"
    },
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 10,
      "id" : "search-in-rotated-sorted-array",
      "pattern" : "binarySearch",
      "prompt" : "There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed).\n\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\n\nExample 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\n\nConstraints:\n- 1 <= nums.length <= 5000\n- -10^4 <= nums[i] <= 10^4\n- All values of nums are unique.",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func search(_ nums: [Int], _ target: Int) -> Int {\n    var left = 0\n    var right = nums.count - 1\n    \n    while left <= right {\n        let mid = left + (right - left) \/ 2\n        \n        if nums[mid] == target {\n            return mid\n        }\n        \n        \/\/ Left half is sorted\n        if nums[left] <= nums[mid] {\n            if target >= nums[left] && target < nums[mid] {\n                right = mid - 1\n            } else {\n                left = mid + 1\n            }\n        }\n        \/\/ Right half is sorted\n        else {\n            if target > nums[mid] && target <= nums[right] {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n    }\n    \n    return -1\n}",
          "wrapper" : "\n\nlet input = readLine()!.split(separator: \"|\")\nlet nums = input[0].dropFirst().dropLast().split(separator: \",\").map { Int($0.trimmingCharacters(in: .whitespaces))! }\nlet target = Int(input[1].trimmingCharacters(in: .whitespaces))!\nprint(search(nums, target))"
        },
        {
          "language" : "python",
          "code" : "def search(nums, target):\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if nums[mid] == target:\n            return mid\n        \n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return -1",
          "wrapper" : "\n\nline = input().split('|')\nnums = list(map(int, line[0].strip('[]').replace(' ', '').split(',')))\ntarget = int(line[1])\nprint(search(nums, target))"
        },
        {
          "language" : "java",
          "code" : "class Solution {\n    public static int search(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            }\n            \n            if (nums[left] <= nums[mid]) {\n                if (nums[left] <= target && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[right]) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        \n        return -1;\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] parts = sc.nextLine().split(\"\\\\|\");\n        String[] nums = parts[0].replace(\"[\", \"\").replace(\"]\", \"\").replace(\" \", \"\").split(\",\");\n        int[] arr = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            arr[i] = Integer.parseInt(nums[i]);\n        }\n        int target = Integer.parseInt(parts[1].trim());\n        System.out.println(Solution.search(arr, target));\n    }\n}"
        }
      ],
      "tags" : [
        "binary search",
        "array"
      ],
      "testCases" : [
        {
          "expectedOutput" : "4",
          "explanation" : "Target 0 is at index 4",
          "input" : "[4,5,6,7,0,1,2]|0"
        },
        {
          "expectedOutput" : "-1",
          "explanation" : "Target 3 is not in the array",
          "input" : "[4,5,6,7,0,1,2]|3"
        },
        {
          "expectedOutput" : "-1",
          "input" : "[1]|0"
        }
      ],
      "title" : "Search in Rotated Sorted Array"
    },
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 12,
      "id" : "koko-eating-bananas",
      "pattern" : "binarySearch",
      "prompt" : "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\n\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn the minimum integer k such that she can eat all the bananas within h hours.\n\nExample 1:\nInput: piles = [3,6,7,11], h = 8\nOutput: 4\n\nExample 2:\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\n\nConstraints:\n- 1 <= piles.length <= 10^4\n- piles.length <= h <= 10^9\n- 1 <= piles[i] <= 10^9",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func minEatingSpeed(_ piles: [Int], _ h: Int) -> Int {\n    var left = 1\n    var right = piles.max()!\n    \n    while left < right {\n        let mid = left + (right - left) \/ 2\n        \n        if canFinish(piles, mid, h) {\n            right = mid\n        } else {\n            left = mid + 1\n        }\n    }\n    \n    return left\n}\n\nfunc canFinish(_ piles: [Int], _ k: Int, _ h: Int) -> Bool {\n    var hours = 0\n    for pile in piles {\n        hours += (pile + k - 1) \/ k  \/\/ Ceiling division\n    }\n    return hours <= h\n}",
          "wrapper" : "\n\nlet input = readLine()!.split(separator: \"|\")\nlet piles = input[0].dropFirst().dropLast().split(separator: \",\").map { Int($0)! }\nlet h = Int(input[1])!\nprint(minEatingSpeed(piles, h))"
        },
        {
          "language" : "python",
          "code" : "def minEatingSpeed(piles, h):\n    import math\n    left = 1\n    right = max(piles)\n    \n    while left < right:\n        mid = left + (right - left) \/\/ 2\n        hours = sum(math.ceil(pile \/ mid) for pile in piles)\n        \n        if hours <= h:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left",
          "wrapper" : "\n\nimport math\nline = input().split('|')\npiles = list(map(int, line[0].strip('[]').split(',')))\nh = int(line[1])\nprint(minEatingSpeed(piles, h))"
        },
        {
          "language" : "java",
          "code" : "class Solution {\n    public static int minEatingSpeed(int[] piles, int h) {\n        int left = 1;\n        int right = 0;\n        for (int pile : piles) {\n            right = Math.max(right, pile);\n        }\n        \n        while (left < right) {\n            int mid = left + (right - left) \/ 2;\n            long hours = 0;\n            for (int pile : piles) {\n                hours += (pile + mid - 1) \/ mid;\n            }\n            \n            if (hours <= h) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        return left;\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] parts = sc.nextLine().split(\"\\\\|\");\n        String[] nums = parts[0].replace(\"[\", \"\").replace(\"]\", \"\").split(\",\");\n        int[] piles = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            piles[i] = Integer.parseInt(nums[i].trim());\n        }\n        int h = Integer.parseInt(parts[1]);\n        System.out.println(Solution.minEatingSpeed(piles, h));\n    }\n}"
        }
      ],
      "tags" : [
        "binary search",
        "array",
        "binary search on answer"
      ],
      "testCases" : [
        {
          "expectedOutput" : "4",
          "explanation" : "Koko can eat at speed 4 and finish in 8 hours",
          "input" : "[3,6,7,11]|8"
        },
        {
          "expectedOutput" : "30",
          "explanation" : "Koko must eat at speed 30 to finish in 5 hours",
          "input" : "[30,11,23,4,20]|5"
        }
      ],
      "title" : "Koko Eating Bananas"
    },
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 10,
      "id" : "top-k-frequent-elements",
      "pattern" : "heap",
      "prompt" : "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\n\nExample 1:\nInput: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\n\nExample 2:\nInput: nums = [1], k = 1\nOutput: [1]\n\nConstraints:\n- 1 <= nums.length <= 10^5\n- -10^4 <= nums[i] <= 10^4\n- k is in the range [1, the number of unique elements in the array].\n- It is guaranteed that the answer is unique.",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func topKFrequent(_ nums: [Int], _ k: Int) -> [Int] {\n    var freqMap = [Int: Int]()\n    for num in nums {\n        freqMap[num, default: 0] += 1\n    }\n    \n    \/\/ Bucket sort by frequency\n    var buckets = Array(repeating: [Int](), count: nums.count + 1)\n    for (num, freq) in freqMap {\n        buckets[freq].append(num)\n    }\n    \n    var result = [Int]()\n    for i in stride(from: buckets.count - 1, through: 0, by: -1) {\n        result.append(contentsOf: buckets[i])\n        if result.count >= k {\n            break\n        }\n    }\n    \n    return Array(result.prefix(k))\n}",
          "wrapper" : "\n\nlet input = readLine()!.split(separator: \"|\")\nlet nums = input[0].dropFirst().dropLast().split(separator: \",\").map { Int($0)! }\nlet k = Int(input[1])!\nlet result = topKFrequent(nums, k)\nprint(\"[\" + result.map(String.init).joined(separator: \",\") + \"]\")"
        },
        {
          "language" : "python",
          "code" : "def topKFrequent(nums, k):\n    from collections import Counter\n    count = Counter(nums)\n    buckets = [[] for _ in range(len(nums) + 1)]\n    \n    for num, freq in count.items():\n        buckets[freq].append(num)\n    \n    result = []\n    for i in range(len(buckets) - 1, 0, -1):\n        result.extend(buckets[i])\n        if len(result) >= k:\n            break\n    \n    return result[:k]",
          "wrapper" : "\n\nline = input().split('|')\nnums = list(map(int, line[0].strip('[]').split(',')))\nk = int(line[1])\nresult = topKFrequent(nums, k)\nprint('[' + ','.join(map(str, result)) + ']')"
        },
        {
          "language" : "java",
          "code" : "import java.util.*;\n\nclass Solution {\n    public static List<Integer> topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int num : nums) {\n            count.put(num, count.getOrDefault(num, 0) + 1);\n        }\n        \n        List<Integer>[] buckets = new ArrayList[nums.length + 1];\n        for (int i = 0; i <= nums.length; i++) {\n            buckets[i] = new ArrayList<>();\n        }\n        \n        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n            buckets[entry.getValue()].add(entry.getKey());\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        for (int i = buckets.length - 1; i >= 0 && result.size() < k; i--) {\n            result.addAll(buckets[i]);\n        }\n        \n        return result.subList(0, Math.min(k, result.size()));\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] parts = sc.nextLine().split(\"\\\\|\");\n        String[] nums = parts[0].replace(\"[\", \"\").replace(\"]\", \"\").split(\",\");\n        int[] arr = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            arr[i] = Integer.parseInt(nums[i].trim());\n        }\n        int k = Integer.parseInt(parts[1]);\n        List<Integer> result = Solution.topKFrequent(arr, k);\n        System.out.print(\"[\");\n        for (int i = 0; i < result.size(); i++) {\n            System.out.print(result.get(i));\n            if (i < result.size() - 1) System.out.print(\",\");\n        }\n        System.out.println(\"]\");\n    }\n}"
        }
      ],
      "tags" : [
        "hash map",
        "heap",
        "bucket sort"
      ],
      "testCases" : [
        {
          "expectedOutput" : "[1,2]",
          "explanation" : "1 appears 3 times and 2 appears 2 times",
          "input" : "[1,1,1,2,2,3]|2"
        },
        {
          "expectedOutput" : "[1]",
          "explanation" : "1 is the only element",
          "input" : "[1]|1"
        }
      ],
      "title" : "Top K Frequent Elements"
    },
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 8,
      "id" : "group-anagrams",
      "pattern" : "heap",
      "prompt" : "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nExample 1:\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\nExample 2:\nInput: strs = [\"\"]\nOutput: [[\"\"]]\n\nExample 3:\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\n\nConstraints:\n- 1 <= strs.length <= 10^4\n- 0 <= strs[i].length <= 100\n- strs[i] consists of lowercase English letters.",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func groupAnagrams(_ strs: [String]) -> [[String]] {\n    var groups = [String: [String]]()\n    \n    for str in strs {\n        let key = String(str.sorted())\n        groups[key, default: []].append(str)\n    }\n    \n    return Array(groups.values)\n}",
          "wrapper" : "\n\nlet input = readLine()!.dropFirst().dropLast()\nlet strs = input.split(separator: \",\").map { str in\n    String(str.dropFirst().dropLast())\n}\nlet result = groupAnagrams(strs)\nlet output = \"[\" + result.map { group in\n    \"[\" + group.map { \"\\\"\\($0)\\\"\" }.joined(separator: \",\") + \"]\"\n}.joined(separator: \",\") + \"]\"\nprint(output)"
        },
        {
          "language" : "python",
          "code" : "def groupAnagrams(strs):\n    from collections import defaultdict\n    groups = defaultdict(list)\n    \n    for s in strs:\n        key = ''.join(sorted(s))\n        groups[key].append(s)\n    \n    return list(groups.values())",
          "wrapper" : "\n\nimport json\ninput_str = input().strip('[]')\nstrs = json.loads('[' + input_str + ']')\nresult = groupAnagrams(strs)\nprint(json.dumps(result))"
        },
        {
          "language" : "java",
          "code" : "import java.util.*;\n\nclass Solution {\n    public static List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> groups = new HashMap<>();\n        \n        for (String str : strs) {\n            char[] chars = str.toCharArray();\n            Arrays.sort(chars);\n            String key = new String(chars);\n            \n            groups.putIfAbsent(key, new ArrayList<>());\n            groups.get(key).add(str);\n        }\n        \n        return new ArrayList<>(groups.values());\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String input = sc.nextLine().replaceAll(\"[\\[\\]]\", \"\");\n        String[] parts = input.split(\",\");\n        String[] strs = new String[parts.length];\n        for (int i = 0; i < parts.length; i++) {\n            strs[i] = parts[i].replaceAll(\"\\\"\", \"\").trim();\n        }\n        List<List<String>> result = Solution.groupAnagrams(strs);\n        System.out.print(\"[\");\n        for (int i = 0; i < result.size(); i++) {\n            System.out.print(\"[\");\n            for (int j = 0; j < result.get(i).size(); j++) {\n                System.out.print(\"\\\"\" + result.get(i).get(j) + \"\\\"\");\n                if (j < result.get(i).size() - 1) System.out.print(\",\");\n            }\n            System.out.print(\"]\");\n            if (i < result.size() - 1) System.out.print(\",\");\n        }\n        System.out.println(\"]\");\n    }\n}"
        }
      ],
      "tags" : [
        "hash map",
        "string",
        "sorting"
      ],
      "testCases" : [
        {
          "expectedOutput" : "[[\"ate\",\"eat\",\"tea\"],[\"bat\"],[\"nat\",\"tan\"]]",
          "explanation" : "Anagrams are grouped together",
          "input" : "[\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]"
        }
      ],
      "title" : "Group Anagrams"
    },
    {
      "difficulty" : "easy",
      "estimatedTimeMinutes" : 5,
      "id" : "valid-anagram",
      "pattern" : "heap",
      "prompt" : "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nExample 1:\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nExample 2:\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nConstraints:\n- 1 <= s.length, t.length <= 5 * 10^4\n- s and t consist of lowercase English letters.",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func isAnagram(_ s: String, _ t: String) -> Bool {\n    guard s.count == t.count else { return false }\n    \n    var charCount = [Character: Int]()\n    \n    for char in s {\n        charCount[char, default: 0] += 1\n    }\n    \n    for char in t {\n        guard let count = charCount[char], count > 0 else {\n            return false\n        }\n        charCount[char]! -= 1\n    }\n    \n    return true\n}",
          "wrapper" : "\n\nlet input = readLine()!.split(separator: \"|\")\nlet s = String(input[0])\nlet t = String(input[1])\nprint(isAnagram(s, t))"
        },
        {
          "language" : "python",
          "code" : "def isAnagram(s, t):\n    if len(s) != len(t):\n        return False\n    \n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    for char in t:\n        if char not in char_count or char_count[char] == 0:\n            return False\n        char_count[char] -= 1\n    \n    return True",
          "wrapper" : "\n\nline = input().split('|')\ns = line[0]\nt = line[1]\nprint('true' if isAnagram(s, t) else 'false')"
        },
        {
          "language" : "java",
          "code" : "import java.util.*;\n\nclass Solution {\n    public static boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) return false;\n        \n        Map<Character, Integer> charCount = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n        }\n        \n        for (char c : t.toCharArray()) {\n            if (!charCount.containsKey(c) || charCount.get(c) == 0) {\n                return false;\n            }\n            charCount.put(c, charCount.get(c) - 1);\n        }\n        \n        return true;\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] parts = sc.nextLine().split(\"\\\\|\");\n        String s = parts[0];\n        String t = parts[1];\n        System.out.println(Solution.isAnagram(s, t));\n    }\n}"
        }
      ],
      "tags" : [
        "hash map",
        "string",
        "sorting"
      ],
      "testCases" : [
        {
          "expectedOutput" : "true",
          "explanation" : "Both strings have the same characters",
          "input" : "anagram|nagaram"
        },
        {
          "expectedOutput" : "false",
          "explanation" : "Different characters",
          "input" : "rat|car"
        }
      ],
      "title" : "Valid Anagram"
    },
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 8,
      "id" : "merge-intervals",
      "pattern" : "intervals",
      "prompt" : "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\nExample 1:\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\nExample 2:\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n\nConstraints:\n- 1 <= intervals.length <= 10^4\n- intervals[i].length == 2\n- 0 <= starti <= endi <= 10^4",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func merge(_ intervals: [[Int]]) -> [[Int]] {\n    guard !intervals.isEmpty else { return [] }\n    \n    let sorted = intervals.sorted { $0[0] < $1[0] }\n    var merged: [[Int]] = [sorted[0]]\n    \n    for interval in sorted.dropFirst() {\n        if interval[0] <= merged[merged.count - 1][1] {\n            \/\/ Overlapping - merge\n            merged[merged.count - 1][1] = max(merged[merged.count - 1][1], interval[1])\n        } else {\n            \/\/ Non-overlapping - add new interval\n            merged.append(interval)\n        }\n    }\n    \n    return merged\n}",
          "wrapper" : "\n\nlet input = readLine()!.dropFirst().dropLast()\nlet intervals = input.split(separator: \"]\").dropLast().map { interval -> [Int] in\n    let nums = interval.trimmingCharacters(in: CharacterSet(charactersIn: \"[,\")).split(separator: \",\").map { Int($0.trimmingCharacters(in: .whitespaces))! }\n    return nums\n}\nlet result = merge(intervals)\nprint(\"[\" + result.map { \"[\" + $0.map(String.init).joined(separator: \",\") + \"]\" }.joined(separator: \",\") + \"]\")"
        },
        {
          "language" : "python",
          "code" : "def merge(intervals):\n    if not intervals:\n        return []\n    \n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    \n    for interval in intervals[1:]:\n        if interval[0] <= merged[-1][1]:\n            # Overlapping - merge\n            merged[-1][1] = max(merged[-1][1], interval[1])\n        else:\n            # Non-overlapping - add new interval\n            merged.append(interval)\n    \n    return merged",
          "wrapper" : "\n\nimport json\ninput_str = input()\nintervals = json.loads(input_str)\nresult = merge(intervals)\nprint(json.dumps(result))"
        },
        {
          "language" : "java",
          "code" : "import java.util.*;\n\nclass Solution {\n    public static int[][] merge(int[][] intervals) {\n        if (intervals.length == 0) return new int[0][];\n        \n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n        List<int[]> merged = new ArrayList<>();\n        merged.add(intervals[0]);\n        \n        for (int i = 1; i < intervals.length; i++) {\n            int[] current = intervals[i];\n            int[] last = merged.get(merged.size() - 1);\n            \n            if (current[0] <= last[1]) {\n                // Overlapping - merge\n                last[1] = Math.max(last[1], current[1]);\n            } else {\n                // Non-overlapping - add new interval\n                merged.add(current);\n            }\n        }\n        \n        return merged.toArray(new int[merged.size()][]);\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String input = sc.nextLine();\n        input = input.substring(1, input.length() - 1);\n        String[] parts = input.split(\"\\\\],\\\\[\");\n        int[][] intervals = new int[parts.length][2];\n        for (int i = 0; i < parts.length; i++) {\n            String part = parts[i].replaceAll(\"[\\\\[\\\\]]\", \"\");\n            String[] nums = part.split(\",\");\n            intervals[i][0] = Integer.parseInt(nums[0]);\n            intervals[i][1] = Integer.parseInt(nums[1]);\n        }\n        int[][] result = Solution.merge(intervals);\n        System.out.print(\"[\");\n        for (int i = 0; i < result.length; i++) {\n            System.out.print(\"[\" + result[i][0] + \",\" + result[i][1] + \"]\");\n            if (i < result.length - 1) System.out.print(\",\");\n        }\n        System.out.println(\"]\");\n    }\n}"
        }
      ],
      "tags" : [
        "intervals",
        "array",
        "sorting"
      ],
      "testCases" : [
        {
          "expectedOutput" : "[[1,6],[8,10],[15,18]]",
          "explanation" : "Overlapping intervals are merged",
          "input" : "[[1,3],[2,6],[8,10],[15,18]]"
        },
        {
          "expectedOutput" : "[[1,5]]",
          "explanation" : "Adjacent intervals are merged",
          "input" : "[[1,4],[4,5]]"
        }
      ],
      "title" : "Merge Intervals"
    },
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 10,
      "id" : "insert-interval",
      "pattern" : "intervals",
      "prompt" : "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\n\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n\nReturn intervals after the insertion.\n\nExample 1:\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n\nExample 2:\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n\nConstraints:\n- 0 <= intervals.length <= 10^4\n- intervals[i].length == 2\n- 0 <= starti <= endi <= 10^5",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\n    var result: [[Int]] = []\n    var newInt = newInterval\n    var i = 0\n    \n    \/\/ Add all intervals before newInterval\n    while i < intervals.count && intervals[i][1] < newInt[0] {\n        result.append(intervals[i])\n        i += 1\n    }\n    \n    \/\/ Merge overlapping intervals\n    while i < intervals.count && intervals[i][0] <= newInt[1] {\n        newInt[0] = min(newInt[0], intervals[i][0])\n        newInt[1] = max(newInt[1], intervals[i][1])\n        i += 1\n    }\n    result.append(newInt)\n    \n    \/\/ Add remaining intervals\n    while i < intervals.count {\n        result.append(intervals[i])\n        i += 1\n    }\n    \n    return result\n}",
          "wrapper" : "\n\nlet input = readLine()!.split(separator: \"|\")\nlet intervalsStr = input[0].dropFirst().dropLast()\nlet intervals = intervalsStr.split(separator: \"]\").dropLast().map { interval -> [Int] in\n    let nums = interval.trimmingCharacters(in: CharacterSet(charactersIn: \"[,\")).split(separator: \",\").map { Int($0.trimmingCharacters(in: .whitespaces))! }\n    return nums\n}\nlet newInterval = input[1].dropFirst().dropLast().split(separator: \",\").map { Int($0)! }\nlet result = insert(intervals, newInterval)\nprint(\"[\" + result.map { \"[\" + $0.map(String.init).joined(separator: \",\") + \"]\" }.joined(separator: \",\") + \"]\")"
        },
        {
          "language" : "python",
          "code" : "def insert(intervals, newInterval):\n    result = []\n    i = 0\n    \n    # Add all intervals before newInterval\n    while i < len(intervals) and intervals[i][1] < newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n    \n    # Merge overlapping intervals\n    while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n    result.append(newInterval)\n    \n    # Add remaining intervals\n    while i < len(intervals):\n        result.append(intervals[i])\n        i += 1\n    \n    return result",
          "wrapper" : "\n\nimport json\nparts = input().split('|')\nintervals = json.loads(parts[0])\nnewInterval = json.loads(parts[1])\nresult = insert(intervals, newInterval)\nprint(json.dumps(result))"
        },
        {
          "language" : "java",
          "code" : "import java.util.*;\n\nclass Solution {\n    public static int[][] insert(int[][] intervals, int[] newInterval) {\n        List<int[]> result = new ArrayList<>();\n        int i = 0;\n        \n        // Add all intervals before newInterval\n        while (i < intervals.length && intervals[i][1] < newInterval[0]) {\n            result.add(intervals[i]);\n            i++;\n        }\n        \n        // Merge overlapping intervals\n        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n            i++;\n        }\n        result.add(newInterval);\n        \n        // Add remaining intervals\n        while (i < intervals.length) {\n            result.add(intervals[i]);\n            i++;\n        }\n        \n        return result.toArray(new int[result.size()][]);\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] parts = sc.nextLine().split(\"\\\\|\");\n        String intervalsStr = parts[0].substring(1, parts[0].length() - 1);\n        String[] intervalParts = intervalsStr.split(\"\\\\],\\\\[\");\n        int[][] intervals = new int[intervalParts.length][2];\n        for (int i = 0; i < intervalParts.length; i++) {\n            String part = intervalParts[i].replaceAll(\"[\\\\[\\\\]]\", \"\");\n            String[] nums = part.split(\",\");\n            intervals[i][0] = Integer.parseInt(nums[0]);\n            intervals[i][1] = Integer.parseInt(nums[1]);\n        }\n        String newIntStr = parts[1].replaceAll(\"[\\\\[\\\\]]\", \"\");\n        String[] newIntNums = newIntStr.split(\",\");\n        int[] newInterval = {Integer.parseInt(newIntNums[0]), Integer.parseInt(newIntNums[1])};\n        int[][] result = Solution.insert(intervals, newInterval);\n        System.out.print(\"[\");\n        for (int i = 0; i < result.length; i++) {\n            System.out.print(\"[\" + result[i][0] + \",\" + result[i][1] + \"]\");\n            if (i < result.length - 1) System.out.print(\",\");\n        }\n        System.out.println(\"]\");\n    }\n}"
        }
      ],
      "tags" : [
        "intervals",
        "array"
      ],
      "testCases" : [
        {
          "expectedOutput" : "[[1,5],[6,9]]",
          "explanation" : "New interval overlaps with [1,3]",
          "input" : "[[1,3],[6,9]]|[2,5]"
        },
        {
          "expectedOutput" : "[[1,2],[3,10],[12,16]]",
          "explanation" : "New interval merges multiple intervals",
          "input" : "[[1,2],[3,5],[6,7],[8,10],[12,16]]|[4,8]"
        }
      ],
      "title" : "Insert Interval"
    },
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 12,
      "id" : "meeting-rooms-ii",
      "pattern" : "heap",
      "prompt" : "Given an array of meeting time intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.\n\nExample 1:\nInput: intervals = [[0,30],[5,10],[15,20]]\nOutput: 2\nExplanation: One room for [0,30] and another for [5,10] and [15,20].\n\nExample 2:\nInput: intervals = [[7,10],[2,4]]\nOutput: 1\n\nConstraints:\n- 1 <= intervals.length <= 10^4\n- 0 <= starti < endi <= 10^6",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func minMeetingRooms(_ intervals: [[Int]]) -> Int {\n    guard !intervals.isEmpty else { return 0 }\n    \n    let sorted = intervals.sorted { $0[0] < $1[0] }\n    var endTimes: [Int] = []  \/\/ Min heap simulation\n    \n    for interval in sorted {\n        \/\/ If earliest ending meeting has ended, reuse that room\n        if !endTimes.isEmpty && endTimes[0] <= interval[0] {\n            endTimes.removeFirst()\n        }\n        \n        \/\/ Add current meeting's end time\n        endTimes.append(interval[1])\n        endTimes.sort()  \/\/ Maintain min heap\n    }\n    \n    return endTimes.count\n}",
          "wrapper" : "\n\nlet input = readLine()!.dropFirst().dropLast()\nlet intervals = input.split(separator: \"]\").dropLast().map { interval -> [Int] in\n    let nums = interval.trimmingCharacters(in: CharacterSet(charactersIn: \"[,\")).split(separator: \",\").map { Int($0.trimmingCharacters(in: .whitespaces))! }\n    return nums\n}\nlet result = minMeetingRooms(intervals)\nprint(result)"
        },
        {
          "language" : "python",
          "code" : "def minMeetingRooms(intervals):\n    if not intervals:\n        return 0\n    \n    intervals.sort(key=lambda x: x[0])\n    import heapq\n    heap = []\n    \n    for interval in intervals:\n        # If earliest ending meeting has ended, reuse that room\n        if heap and heap[0] <= interval[0]:\n            heapq.heappop(heap)\n        \n        # Add current meeting's end time\n        heapq.heappush(heap, interval[1])\n    \n    return len(heap)",
          "wrapper" : "\n\nimport json\ninput_str = input()\nintervals = json.loads(input_str)\nresult = minMeetingRooms(intervals)\nprint(result)"
        },
        {
          "language" : "java",
          "code" : "import java.util.*;\n\nclass Solution {\n    public static int minMeetingRooms(int[][] intervals) {\n        if (intervals.length == 0) return 0;\n        \n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n        PriorityQueue<Integer> heap = new PriorityQueue<>();\n        \n        for (int[] interval : intervals) {\n            // If earliest ending meeting has ended, reuse that room\n            if (!heap.isEmpty() && heap.peek() <= interval[0]) {\n                heap.poll();\n            }\n            \n            // Add current meeting's end time\n            heap.offer(interval[1]);\n        }\n        \n        return heap.size();\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String input = sc.nextLine();\n        input = input.substring(1, input.length() - 1);\n        String[] parts = input.split(\"\\\\],\\\\[\");\n        int[][] intervals = new int[parts.length][2];\n        for (int i = 0; i < parts.length; i++) {\n            String part = parts[i].replaceAll(\"[\\\\[\\\\]]\", \"\");\n            String[] nums = part.split(\",\");\n            intervals[i][0] = Integer.parseInt(nums[0]);\n            intervals[i][1] = Integer.parseInt(nums[1]);\n        }\n        int result = Solution.minMeetingRooms(intervals);\n        System.out.println(result);\n    }\n}"
        }
      ],
      "tags" : [
        "intervals",
        "heap",
        "sorting"
      ],
      "testCases" : [
        {
          "expectedOutput" : "2",
          "explanation" : "Need 2 rooms for overlapping meetings",
          "input" : "[[0,30],[5,10],[15,20]]"
        },
        {
          "expectedOutput" : "1",
          "explanation" : "Only 1 room needed",
          "input" : "[[7,10],[2,4]]"
        }
      ],
      "title" : "Meeting Rooms II"
    },
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 12,
      "id" : "number-of-islands",
      "pattern" : "graphBFS",
      "prompt" : "Given an m x n 2D binary grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\nExample 1:\nInput: grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nOutput: 1\n\nExample 2:\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n\nConstraints:\n- m == grid.length\n- n == grid[i].length\n- 1 <= m, n <= 300\n- grid[i][j] is '0' or '1'.",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func numIslands(_ grid: [[Character]]) -> Int {\n    guard !grid.isEmpty else { return 0 }\n    var grid = grid\n    var count = 0\n    \n    func bfs(_ row: Int, _ col: Int) {\n        var queue = [(row, col)]\n        grid[row][col] = \"0\"\n        \n        let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        while !queue.isEmpty {\n            let (r, c) = queue.removeFirst()\n            \n            for (dr, dc) in directions {\n                let newR = r + dr\n                let newC = c + dc\n                \n                if newR >= 0 && newR < grid.count &&\n                   newC >= 0 && newC < grid[0].count &&\n                   grid[newR][newC] == \"1\" {\n                    grid[newR][newC] = \"0\"\n                    queue.append((newR, newC))\n                }\n            }\n        }\n    }\n    \n    for i in 0..<grid.count {\n        for j in 0..<grid[0].count {\n            if grid[i][j] == \"1\" {\n                count += 1\n                bfs(i, j)\n            }\n        }\n    }\n    \n    return count\n}",
          "wrapper" : "\n\nlet input = readLine()!.dropFirst().dropLast()\nlet grid = input.split(separator: \"]\").dropLast().map { row -> [Character] in\n    let chars = row.trimmingCharacters(in: CharacterSet(charactersIn: \"[,\")).split(separator: \",\").map { Character($0.trimmingCharacters(in: CharacterSet(charactersIn: \" \\\"\"))) }\n    return chars\n}\nlet result = numIslands(grid)\nprint(result)"
        },
        {
          "language" : "python",
          "code" : "def numIslands(grid):\n    if not grid:\n        return 0\n    \n    count = 0\n    rows, cols = len(grid), len(grid[0])\n    \n    def bfs(row, col):\n        queue = [(row, col)]\n        grid[row][col] = '0'\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        while queue:\n            r, c = queue.pop(0)\n            for dr, dc in directions:\n                new_r, new_c = r + dr, c + dc\n                if (0 <= new_r < rows and 0 <= new_c < cols and \n                    grid[new_r][new_c] == '1'):\n                    grid[new_r][new_c] = '0'\n                    queue.append((new_r, new_c))\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                count += 1\n                bfs(i, j)\n    \n    return count",
          "wrapper" : "\n\nimport json\ninput_str = input()\ngrid = json.loads(input_str)\nresult = numIslands(grid)\nprint(result)"
        },
        {
          "language" : "java",
          "code" : "import java.util.*;\n\nclass Solution {\n    public static int numIslands(char[][] grid) {\n        if (grid.length == 0) return 0;\n        \n        int count = 0;\n        int rows = grid.length;\n        int cols = grid[0].length;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == '1') {\n                    count++;\n                    bfs(grid, i, j);\n                }\n            }\n        }\n        return count;\n    }\n    \n    private static void bfs(char[][] grid, int row, int col) {\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{row, col});\n        grid[row][col] = '0';\n        int[][] directions = {{0,1}, {1,0}, {0,-1}, {-1,0}};\n        \n        while (!queue.isEmpty()) {\n            int[] cell = queue.poll();\n            for (int[] dir : directions) {\n                int newR = cell[0] + dir[0];\n                int newC = cell[1] + dir[1];\n                if (newR >= 0 && newR < grid.length && \n                    newC >= 0 && newC < grid[0].length && \n                    grid[newR][newC] == '1') {\n                    grid[newR][newC] = '0';\n                    queue.offer(new int[]{newR, newC});\n                }\n            }\n        }\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String input = sc.nextLine();\n        input = input.substring(1, input.length() - 1);\n        String[] rows = input.split(\"\\\\],\\\\[\");\n        char[][] grid = new char[rows.length][];\n        for (int i = 0; i < rows.length; i++) {\n            String row = rows[i].replaceAll(\"[\\\\[\\\\]]\", \"\");\n            String[] cells = row.split(\",\");\n            grid[i] = new char[cells.length];\n            for (int j = 0; j < cells.length; j++) {\n                grid[i][j] = cells[j].replaceAll(\"\\\"\", \"\").trim().charAt(0);\n            }\n        }\n        int result = Solution.numIslands(grid);\n        System.out.println(result);\n    }\n}"
        }
      ],
      "tags" : [
        "graph",
        "bfs",
        "dfs",
        "matrix"
      ],
      "testCases" : [
        {
          "expectedOutput" : "1",
          "explanation" : "All 1s form a single island",
          "input" : "[[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]"
        },
        {
          "expectedOutput" : "3",
          "explanation" : "Three separate islands",
          "input" : "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]"
        }
      ],
      "title" : "Number of Islands"
    },
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 12,
      "id" : "shortest-path-in-binary-matrix",
      "pattern" : "graphBFS",
      "prompt" : "Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.\n\nA clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:\n- All the visited cells of the path are 0.\n- All the adjacent cells of the path are 8-directionally connected.\n\nThe length of a clear path is the number of visited cells of this path.\n\nExample 1:\nInput: grid = [[0,1],[1,0]]\nOutput: 2\n\nExample 2:\nInput: grid = [[0,0,0],[1,1,0],[1,1,0]]\nOutput: 4\n\nConstraints:\n- n == grid.length\n- n == grid[i].length\n- 1 <= n <= 100\n- grid[i][j] is 0 or 1",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "func shortestPathBinaryMatrix(_ grid: [[Int]]) -> Int {\n    let n = grid.count\n    guard grid[0][0] == 0 && grid[n-1][n-1] == 0 else { return -1 }\n    \n    var grid = grid\n    var queue: [(Int, Int, Int)] = [(0, 0, 1)]  \/\/ row, col, distance\n    grid[0][0] = 1  \/\/ Mark as visited\n    \n    let directions = [\n        (-1, -1), (-1, 0), (-1, 1),\n        (0, -1),           (0, 1),\n        (1, -1),  (1, 0),  (1, 1)\n    ]\n    \n    while !queue.isEmpty {\n        let (row, col, dist) = queue.removeFirst()\n        \n        if row == n - 1 && col == n - 1 {\n            return dist\n        }\n        \n        for (dr, dc) in directions {\n            let newR = row + dr\n            let newC = col + dc\n            \n            if newR >= 0 && newR < n &&\n               newC >= 0 && newC < n &&\n               grid[newR][newC] == 0 {\n                grid[newR][newC] = 1\n                queue.append((newR, newC, dist + 1))\n            }\n        }\n    }\n    \n    return -1\n}",
          "wrapper" : "\n\nlet input = readLine()!.dropFirst().dropLast()\nlet grid = input.split(separator: \"]\").dropLast().map { row -> [Int] in\n    let nums = row.trimmingCharacters(in: CharacterSet(charactersIn: \"[,\")).split(separator: \",\").map { Int($0.trimmingCharacters(in: .whitespaces))! }\n    return nums\n}\nlet result = shortestPathBinaryMatrix(grid)\nprint(result)"
        },
        {
          "language" : "python",
          "code" : "def shortestPathBinaryMatrix(grid):\n    n = len(grid)\n    if grid[0][0] != 0 or grid[n-1][n-1] != 0:\n        return -1\n    \n    from collections import deque\n    queue = deque([(0, 0, 1)])  # row, col, distance\n    grid[0][0] = 1  # Mark as visited\n    \n    directions = [\n        (-1, -1), (-1, 0), (-1, 1),\n        (0, -1),           (0, 1),\n        (1, -1),  (1, 0),  (1, 1)\n    ]\n    \n    while queue:\n        row, col, dist = queue.popleft()\n        \n        if row == n - 1 and col == n - 1:\n            return dist\n        \n        for dr, dc in directions:\n            new_r, new_c = row + dr, col + dc\n            if (0 <= new_r < n and 0 <= new_c < n and \n                grid[new_r][new_c] == 0):\n                grid[new_r][new_c] = 1\n                queue.append((new_r, new_c, dist + 1))\n    \n    return -1",
          "wrapper" : "\n\nimport json\ninput_str = input()\ngrid = json.loads(input_str)\nresult = shortestPathBinaryMatrix(grid)\nprint(result)"
        },
        {
          "language" : "java",
          "code" : "import java.util.*;\n\nclass Solution {\n    public static int shortestPathBinaryMatrix(int[][] grid) {\n        int n = grid.length;\n        if (grid[0][0] != 0 || grid[n-1][n-1] != 0) return -1;\n        \n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 0, 1});  // row, col, distance\n        grid[0][0] = 1;  // Mark as visited\n        \n        int[][] directions = {\n            {-1, -1}, {-1, 0}, {-1, 1},\n            {0, -1},           {0, 1},\n            {1, -1},  {1, 0},  {1, 1}\n        };\n        \n        while (!queue.isEmpty()) {\n            int[] cell = queue.poll();\n            int row = cell[0], col = cell[1], dist = cell[2];\n            \n            if (row == n - 1 && col == n - 1) {\n                return dist;\n            }\n            \n            for (int[] dir : directions) {\n                int newR = row + dir[0];\n                int newC = col + dir[1];\n                if (newR >= 0 && newR < n && newC >= 0 && newC < n && \n                    grid[newR][newC] == 0) {\n                    grid[newR][newC] = 1;\n                    queue.offer(new int[]{newR, newC, dist + 1});\n                }\n            }\n        }\n        \n        return -1;\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String input = sc.nextLine();\n        input = input.substring(1, input.length() - 1);\n        String[] rows = input.split(\"\\\\],\\\\[\");\n        int[][] grid = new int[rows.length][];\n        for (int i = 0; i < rows.length; i++) {\n            String row = rows[i].replaceAll(\"[\\\\[\\\\]]\", \"\");\n            String[] nums = row.split(\",\");\n            grid[i] = new int[nums.length];\n            for (int j = 0; j < nums.length; j++) {\n                grid[i][j] = Integer.parseInt(nums[j]);\n            }\n        }\n        int result = Solution.shortestPathBinaryMatrix(grid);\n        System.out.println(result);\n    }\n}"
        }
      ],
      "tags" : [
        "graph",
        "bfs",
        "matrix",
        "shortest path"
      ],
      "testCases" : [
        {
          "expectedOutput" : "2",
          "explanation" : "Path from (0,0) to (1,1) has length 2",
          "input" : "[[0,1],[1,0]]"
        },
        {
          "expectedOutput" : "4",
          "explanation" : "Clear path has length 4",
          "input" : "[[0,0,0],[1,1,0],[1,1,0]]"
        }
      ],
      "title" : "Shortest Path in Binary Matrix"
    },
    {
      "difficulty" : "medium",
      "estimatedTimeMinutes" : 12,
      "id" : "clone-graph",
      "pattern" : "graphDFS",
      "prompt" : "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph.\n\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\n\nclass Node {\n    public var val: Int\n    public var neighbors: [Node?]\n}\n\nExample 1:\nInput: adjList = [[2,4],[1,3],[2,4],[1,3]]\nOutput: [[2,4],[1,3],[2,4],[1,3]]\nExplanation: There are 4 nodes in the graph.\n\nConstraints:\n- The number of nodes in the graph is in the range [0, 100].\n- 1 <= Node.val <= 100\n- Node.val is unique for each node.",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "class Node {\n    public var val: Int\n    public var neighbors: [Node?]\n    public init(_ val: Int) {\n        self.val = val\n        self.neighbors = []\n    }\n}\n\nfunc cloneGraph(_ node: Node?) -> Node? {\n    guard let node = node else { return nil }\n    \n    var visited = [Int: Node]()\n    \n    func dfs(_ node: Node) -> Node {\n        if let clone = visited[node.val] {\n            return clone\n        }\n        \n        let clone = Node(node.val)\n        visited[node.val] = clone\n        \n        for neighbor in node.neighbors {\n            if let neighbor = neighbor {\n                clone.neighbors.append(dfs(neighbor))\n            }\n        }\n        \n        return clone\n    }\n    \n    return dfs(node)\n}",
          "wrapper" : "\n\nlet input = readLine()!.dropFirst().dropLast()\nlet adjList = input.split(separator: \"]\").dropLast().map { row -> [Int] in\n    let nums = row.trimmingCharacters(in: CharacterSet(charactersIn: \"[,\")).split(separator: \",\").map { Int($0.trimmingCharacters(in: .whitespaces))! }\n    return nums\n}\n\nfunc buildGraph(_ adjList: [[Int]]) -> Node? {\n    guard !adjList.isEmpty else { return nil }\n    var nodes = [Int: Node]()\n    for i in 0..<adjList.count {\n        nodes[i + 1] = Node(i + 1)\n    }\n    for i in 0..<adjList.count {\n        for neighborVal in adjList[i] {\n            nodes[i + 1]?.neighbors.append(nodes[neighborVal])\n        }\n    }\n    return nodes[1]\n}\n\nfunc graphToAdjList(_ node: Node?) -> [[Int]] {\n    guard let node = node else { return [] }\n    var visited = Set<Int>()\n    var result = [[Int]]()\n    var nodeMap = [Int: Node]()\n    \n    func dfs(_ n: Node) {\n        if visited.contains(n.val) { return }\n        visited.insert(n.val)\n        nodeMap[n.val] = n\n        for neighbor in n.neighbors {\n            if let neighbor = neighbor {\n                dfs(neighbor)\n            }\n        }\n    }\n    dfs(node)\n    \n    for i in 1...nodeMap.count {\n        if let n = nodeMap[i] {\n            result.append(n.neighbors.compactMap { $0?.val })\n        }\n    }\n    return result\n}\n\nlet graph = buildGraph(adjList)\nlet cloned = cloneGraph(graph)\nlet result = graphToAdjList(cloned)\nprint(\"[\" + result.map { \"[\" + $0.map(String.init).joined(separator: \",\") + \"]\" }.joined(separator: \",\") + \"]\")"
        },
        {
          "language" : "python",
          "code" : "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node):\n    if not node:\n        return None\n    \n    visited = {}\n    \n    def dfs(node):\n        if node.val in visited:\n            return visited[node.val]\n        \n        clone = Node(node.val)\n        visited[node.val] = clone\n        \n        for neighbor in node.neighbors:\n            clone.neighbors.append(dfs(neighbor))\n        \n        return clone\n    \n    return dfs(node)",
          "wrapper" : "\n\nimport json\n\ndef buildGraph(adjList):\n    if not adjList:\n        return None\n    nodes = {i + 1: Node(i + 1) for i in range(len(adjList))}\n    for i in range(len(adjList)):\n        for neighborVal in adjList[i]:\n            nodes[i + 1].neighbors.append(nodes[neighborVal])\n    return nodes[1]\n\ndef graphToAdjList(node):\n    if not node:\n        return []\n    visited = set()\n    nodeMap = {}\n    \n    def dfs(n):\n        if n.val in visited:\n            return\n        visited.add(n.val)\n        nodeMap[n.val] = n\n        for neighbor in n.neighbors:\n            dfs(neighbor)\n    \n    dfs(node)\n    result = []\n    for i in range(1, len(nodeMap) + 1):\n        result.append([neighbor.val for neighbor in nodeMap[i].neighbors])\n    return result\n\nadjList = json.loads(input())\ngraph = buildGraph(adjList)\ncloned = cloneGraph(graph)\nresult = graphToAdjList(cloned)\nprint(json.dumps(result))"
        },
        {
          "language" : "java",
          "code" : "import java.util.*;\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    \n    public Node(int val) {\n        this.val = val;\n        this.neighbors = new ArrayList<>();\n    }\n}\n\nclass Solution {\n    public static Node cloneGraph(Node node) {\n        if (node == null) return null;\n        \n        Map<Integer, Node> visited = new HashMap<>();\n        return dfs(node, visited);\n    }\n    \n    private static Node dfs(Node node, Map<Integer, Node> visited) {\n        if (visited.containsKey(node.val)) {\n            return visited.get(node.val);\n        }\n        \n        Node clone = new Node(node.val);\n        visited.put(node.val, clone);\n        \n        for (Node neighbor : node.neighbors) {\n            clone.neighbors.add(dfs(neighbor, visited));\n        }\n        \n        return clone;\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String input = sc.nextLine();\n        input = input.substring(1, input.length() - 1);\n        String[] parts = input.split(\"\\\\],\\\\[\");\n        List<List<Integer>> adjList = new ArrayList<>();\n        for (String part : parts) {\n            String cleaned = part.replaceAll(\"[\\\\[\\\\]]\", \"\");\n            List<Integer> neighbors = new ArrayList<>();\n            if (!cleaned.isEmpty()) {\n                for (String num : cleaned.split(\",\")) {\n                    neighbors.add(Integer.parseInt(num));\n                }\n            }\n            adjList.add(neighbors);\n        }\n        \n        Node graph = buildGraph(adjList);\n        Node cloned = Solution.cloneGraph(graph);\n        List<List<Integer>> result = graphToAdjList(cloned);\n        \n        System.out.print(\"[\");\n        for (int i = 0; i < result.size(); i++) {\n            System.out.print(\"[\");\n            for (int j = 0; j < result.get(i).size(); j++) {\n                System.out.print(result.get(i).get(j));\n                if (j < result.get(i).size() - 1) System.out.print(\",\");\n            }\n            System.out.print(\"]\");\n            if (i < result.size() - 1) System.out.print(\",\");\n        }\n        System.out.println(\"]\");\n    }\n    \n    private static Node buildGraph(List<List<Integer>> adjList) {\n        if (adjList.isEmpty()) return null;\n        Map<Integer, Node> nodes = new HashMap<>();\n        for (int i = 0; i < adjList.size(); i++) {\n            nodes.put(i + 1, new Node(i + 1));\n        }\n        for (int i = 0; i < adjList.size(); i++) {\n            for (int neighborVal : adjList.get(i)) {\n                nodes.get(i + 1).neighbors.add(nodes.get(neighborVal));\n            }\n        }\n        return nodes.get(1);\n    }\n    \n    private static List<List<Integer>> graphToAdjList(Node node) {\n        if (node == null) return new ArrayList<>();\n        Set<Integer> visited = new HashSet<>();\n        Map<Integer, Node> nodeMap = new HashMap<>();\n        dfsCollect(node, visited, nodeMap);\n        \n        List<List<Integer>> result = new ArrayList<>();\n        for (int i = 1; i <= nodeMap.size(); i++) {\n            List<Integer> neighbors = new ArrayList<>();\n            for (Node neighbor : nodeMap.get(i).neighbors) {\n                neighbors.add(neighbor.val);\n            }\n            result.add(neighbors);\n        }\n        return result;\n    }\n    \n    private static void dfsCollect(Node n, Set<Integer> visited, Map<Integer, Node> nodeMap) {\n        if (visited.contains(n.val)) return;\n        visited.add(n.val);\n        nodeMap.put(n.val, n);\n        for (Node neighbor : n.neighbors) {\n            dfsCollect(neighbor, visited, nodeMap);\n        }\n    }\n}"
        }
      ],
      "tags" : [
        "graph",
        "dfs",
        "hash map"
      ],
      "testCases" : [
        {
          "expectedOutput" : "[[2,4],[1,3],[2,4],[1,3]]",
          "explanation" : "Clone of a 4-node graph",
          "input" : "[[2,4],[1,3],[2,4],[1,3]]"
        }
      ],
      "title" : "Clone Graph"
    },
    {
      "difficulty" : "easy",
      "estimatedTimeMinutes" : 8,
      "id" : "path-sum-in-binary-tree",
      "pattern" : "graphDFS",
      "prompt" : "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\n\nA leaf is a node with no children.\n\nExample 1:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\nOutput: true\nExplanation: The root-to-leaf path with the target sum is 5->4->11->2.\n\nExample 2:\nInput: root = [1,2,3], targetSum = 5\nOutput: false\n\nConstraints:\n- The number of nodes in the tree is in the range [0, 5000].\n- -1000 <= Node.val <= 1000\n- -1000 <= targetSum <= 1000",
      "solutions" : [
        {
          "language" : "swift",
          "code" : "class TreeNode {\n    public var val: Int\n    public var left: TreeNode?\n    public var right: TreeNode?\n    public init(_ val: Int) {\n        self.val = val\n        self.left = nil\n        self.right = nil\n    }\n}\n\nfunc hasPathSum(_ root: TreeNode?, _ targetSum: Int) -> Bool {\n    guard let root = root else { return false }\n    \n    \/\/ Leaf node\n    if root.left == nil && root.right == nil {\n        return root.val == targetSum\n    }\n    \n    let remaining = targetSum - root.val\n    return hasPathSum(root.left, remaining) || \n           hasPathSum(root.right, remaining)\n}",
          "wrapper" : "\n\nlet input = readLine()!.split(separator: \"|\")\nlet treeArray = input[0].dropFirst().dropLast().split(separator: \",\").map { $0.trimmingCharacters(in: .whitespaces) }\nlet targetSum = Int(input[1])!\n\nfunc buildTree(_ arr: [String]) -> TreeNode? {\n    guard !arr.isEmpty, arr[0] != \"null\" else { return nil }\n    let root = TreeNode(Int(arr[0])!)\n    var queue = [root]\n    var i = 1\n    \n    while i < arr.count {\n        let node = queue.removeFirst()\n        \n        if i < arr.count && arr[i] != \"null\" {\n            node.left = TreeNode(Int(arr[i])!)\n            queue.append(node.left!)\n        }\n        i += 1\n        \n        if i < arr.count && arr[i] != \"null\" {\n            node.right = TreeNode(Int(arr[i])!)\n            queue.append(node.right!)\n        }\n        i += 1\n    }\n    \n    return root\n}\n\nlet root = buildTree(treeArray)\nlet result = hasPathSum(root, targetSum)\nprint(result)"
        },
        {
          "language" : "python",
          "code" : "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef hasPathSum(root, targetSum):\n    if not root:\n        return False\n    \n    # Leaf node\n    if not root.left and not root.right:\n        return root.val == targetSum\n    \n    remaining = targetSum - root.val\n    return hasPathSum(root.left, remaining) or hasPathSum(root.right, remaining)",
          "wrapper" : "\n\ndef buildTree(arr):\n    if not arr or arr[0] == 'null':\n        return None\n    root = TreeNode(int(arr[0]))\n    queue = [root]\n    i = 1\n    while i < len(arr):\n        node = queue.pop(0)\n        if i < len(arr) and arr[i] != 'null':\n            node.left = TreeNode(int(arr[i]))\n            queue.append(node.left)\n        i += 1\n        if i < len(arr) and arr[i] != 'null':\n            node.right = TreeNode(int(arr[i]))\n            queue.append(node.right)\n        i += 1\n    return root\n\nparts = input().split('|')\ntreeArray = parts[0].strip('[]').split(',')\ntargetSum = int(parts[1])\nroot = buildTree(treeArray)\nresult = hasPathSum(root, targetSum)\nprint('true' if result else 'false')"
        },
        {
          "language" : "java",
          "code" : "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int val) { this.val = val; }\n}\n\nclass Solution {\n    public static boolean hasPathSum(TreeNode root, int targetSum) {\n        if (root == null) return false;\n        \n        // Leaf node\n        if (root.left == null && root.right == null) {\n            return root.val == targetSum;\n        }\n        \n        int remaining = targetSum - root.val;\n        return hasPathSum(root.left, remaining) || hasPathSum(root.right, remaining);\n    }\n}",
          "wrapper" : "\n\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] parts = sc.nextLine().split(\"\\\\|\");\n        String treeStr = parts[0].substring(1, parts[0].length() - 1);\n        String[] treeArray = treeStr.split(\",\");\n        int targetSum = Integer.parseInt(parts[1]);\n        \n        TreeNode root = buildTree(treeArray);\n        boolean result = Solution.hasPathSum(root, targetSum);\n        System.out.println(result);\n    }\n    \n    private static TreeNode buildTree(String[] arr) {\n        if (arr.length == 0 || arr[0].equals(\"null\")) return null;\n        TreeNode root = new TreeNode(Integer.parseInt(arr[0]));\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int i = 1;\n        while (i < arr.length) {\n            TreeNode node = queue.poll();\n            if (i < arr.length && !arr[i].trim().equals(\"null\")) {\n                node.left = new TreeNode(Integer.parseInt(arr[i].trim()));\n                queue.offer(node.left);\n            }\n            i++;\n            if (i < arr.length && !arr[i].trim().equals(\"null\")) {\n                node.right = new TreeNode(Integer.parseInt(arr[i].trim()));\n                queue.offer(node.right);\n            }\n            i++;\n        }\n        return root;\n    }\n}"
        }
      ],
      "tags" : [
        "tree",
        "dfs",
        "binary tree"
      ],
      "testCases" : [
        {
          "expectedOutput" : "true",
          "explanation" : "Path 5->4->11->2 sums to 22",
          "input" : "[5,4,8,11,null,13,4,7,2,null,null,null,1]|22"
        },
        {
          "expectedOutput" : "false",
          "explanation" : "No path sums to 5",
          "input" : "[1,2,3]|5"
        }
      ],
      "title" : "Path Sum in Binary Tree"
    }
  ]
}